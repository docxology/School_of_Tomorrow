---
title: Observing Multitasking
id: 7300157449246253960
author: Kirby Urner
published: 2019-08-13T13:03:00.002-07:00
updated: 2019-08-18T08:40:16.797-07:00
blog: control_room
tags: 
---

We'll see if I get to show Uncle Bill around the lattice works gallery, during one of his future trips to Union Station, which is really nearby.  I'm going to suggest a Sunday schedule next time he calls, for traffic reasons.  I think everything we'd want to do, is doing business on Sunday.

In one of my recent videos, I encourage watching oneself through task switching, which continues the observer pattern as "one who watches the attention span".  I'm not saying to judge or immediately set out to redesign.  I'm only saying that "scheduling" is an important responsibility of an operating system.

When I first got to Princeton, our role, as undergrads learning to program, was to submit batches of cards through a card reader, with some JCL (job control language) to start and end the deck.  We were queuing work to be done, not immediately, but whenever the computer had time of undergrad, and grad, projects.  Other jobs had priority.

That was an IBM 360 / 370 mainframe.  I watched it through glass in the basement of the computer center, where monitors also displayed the jobs queue.  We could read in our cards from one of several locations as I recall.  I usually frequented the Equad.  I was from the other side of the C.P. Snow chasm, some might say, however I didn't mind lurking and learning.  I'd always wanted to know about computers.

Nowadays a lot of us have personal computers meaning they're not shared with others in real time.  However, we still want to run numerous apps in the foreground and background, and switch between processes.  The OS (operating system) is just as busy as if a lot of people were using it, or might be.  Single users have the capacity to be resource hogs and max out memory and CPU cycles.

Accepting the finitude of throughput is akin to trusting others to also be interested in problem solving.  I go to use FORTRAN and other languages (APL interactively, at the terminal, more like Logo) on these mainframes, but by the time I arrived at the university, the machines were already well thought out and had been through several editions.

I accepted that world without a lot of benchmarks as to the speed with which it was changing.  Looking back, I have a somewhat better appreciation for how the technology is morphing, but I'd still say my window is limited, which is more accepting of finitude, likewise an innate curiosity to discover more.